# Agenti logici parte 2
Gioved√¨ 31 Ottobre 2019

## Metodi di prova

Ci sono due tipologie di prove che si possono fare:

- **Model Checking**: viene fatta l'enumerazioe delle tabelle di verita, con una complessit√† esponenziale in *n* (numero di simboli nella KB), pu√≤ essere migliorata con euristiche o Hill climbing, ma in questo caso si perde la completezza. 
- **Applicazione di regole di inferenza**: si inizia ad estendere la base di conoscenza utilizzando i dati attuali, se ùú∂ √® tra queste nuove sentenze allora viene inferito, altrimenti ripeto il passo utilizzando le nuove informazioni inferite. L'utilizzo di questa strategia risulta pi√π efficiente ma le sentenze devono essere scritte in una forma normale.

Un problema di logica √® dato che il computer fa fatica a ricononscere due sentenze equivalenti ma scritte in maniera diversa:

$$ \neg S_1 \lor S_2 \land S_3; (S_1 \implies S_2) \land S_3$$

##¬†Forward e Backword Chaining

Un algoritmo di inferenza si √® **completo** quando riesce a derivare tutte le formule derivabili ed √® **corretto** (o sounded) se preserva la verit√† delle formule.

**Forma di Horn**: KB espressa come congiunzione di clausole di Horn. In pratica √® una forma normale che semplifica la complessit√† dell'inferenza logica (complessit√† polinomiale vs esponenziale). Tuttavia, la forma di Horn non permette di rappresentare tutte le formule logiche, ma una buona parte di esse si.

$$ C \land (B \implies A) \land (C \land D \implies B)$$ 
*espressione nella forma di horn*

**Clausola di Horn**: √® un simbolo proposizionale o una congiunzione di simboli che implica un altro simbolo. Una formula √® una clausola di Horn quando √® una disgiunzione di letterali nella quale al massimo un letterale √® positivo. Ogni clausola di Horn pu√≤ essere scritta come un'implicazione in cui la premessa √® una congiunzione di letterali positivi e la conclusione √®√® un singolo letterale positivo.

> $\neg A \lor \neg B \lor C$ √® una clausola di Horn
> 
> (A ‚ãÄ B) => C √® la stessa clausola di Horn espressa come implicazione

Le clausole di Horn che hanno esattamente un letterale positivo sono chiamate clausole definite.
Il letterale positivo prende il nome di testa e quelli negativi formano il corpo della clausola.
Una clausola definita senza letterali negativi si limita ad asserire una determinata proposizione e viene chiamata fatto.
Una clausola di Horn senza letterali positivi pu√≤ essere scritta in forma di implicazione la cui conclusione vale False (utili per definire dei vincoli di integrit√†, come quello che il Wumpus si trova in una sola stanza).

__Non posso esprimere ad esempio la forma $\neg B \lor \neg A$

**Modus Ponens**: per la forma di Horn: date due formule $\alpha \implies \beta$ e $\alpha$, si pu√≤ inferire la formula $\beta$. (cio√® se l‚Äôimplicazione e la promessa sono vere, allora anche $\beta$ deve essere vera). √à completo per basi di coscenza espresse nella forma di Horn.

La correttezza di questa regola si dimostra considerando i possibili valori di verit√† delle formule.

![](./immagini/l12-pones.png)

Questo modo dice che se le precondizioni di una regola sono vere allora √® vera anche la regola.

Pu√≤ essere utilizzato per fare *forward chaining* o *backward chaining*, che sono entrambi algoritmi con complessit√† lineare in tempo.

## Foward Chaining

![](./immagini/l12-albero.png)

L'idea √® quella di applicare ogni regola le cui premesse sono soddisfattte nella KB, una volta fatto ci√≤ pu√≤ essere che alcune regole della KB hanno le promesse soddisfatte grazie alle nuove informazioni precedentemente inserite, fino a quando non viene raggiunto il goal.

Se questo non viene raggiunto vuol dire che la sentenza non √® conseguenza logica della KB.

L'algoritmo √® rappresentato in figura tramite un _grafo AND/OR_. L'archetto tra A e B dice che sia A che B devono essere veri affinch√© si possa raggiungere L (tramite un iper-arco, ovvero la freccia con la punta piena (di odio e terrore)).

```
function CP-CA-Implica(KB, q) returns true or false
    locals: conto, una tabella indicizzata per clausola, che contiene inizialmente in numero di premesse
            inferiti: una tabella indicizzata per simbolo in cui ogni elemento √® inizialmente false
            agenda: una lista di simboli che contiene inizlamente quelli noti come veri nella KB
    while agenda non √® vuota do
        p <- Pop(agenda)
        unless inferiti[p] do
            inferiti[p] <- true
            foreach clausola di Horn c in cui appare la premessa p do
                decrementa conto[c]
                if conto[c] == 0 then do
                    if Testa[c] == q then retrun true
                    Push(Testa[c],agenda)
    return false
```

`Testa[c]` rappresenta quello che la clausola di Horn implica.

Un'osservazione che si pu√≤ fare su questo algoritmo √® che non viene tenuto in considerazione il goal che si vuole raggiungere, semplicemente si va a dedurre il pi√π possibile dalla KB nella speranza che il goal *q* sia deducibile da KB.

Per√≤ se nella KB la query *q* non √® gi√† soddisfatta (non √® un fatto noto) e non ci sono regole di Horn che hanno come conseguenza la query, allora non c'√® speranza di riuscire a dedurre *q* dalla KB e quindi l'algoritmo potrebbe terminare subito.

### Completezza

Il forward chaining applicato con il *modus ponens* deriva tutte le conseguenza della KB.

FC raggiunge un punto fisso dove nessuna nuova sentenza atomica √® derivata, questo perch√© il numero di simboli √® finito.

Lo stato finale che si raggiunge applicando l'algoritmo si pu√≤ considerare come un modello *m*, assegnando vero o falso ai simboli che sono stati inferiti.

Ogni clausola definita nella KB originale √® vera nel modello creato con questo algoritmo.
Per verificare questo punto basta assumere l‚Äôipotesi opposta, e cio√® che qualche clausola *a<sub>1</sub>‚ãÄ ... ‚ãÄ a<sub>k</sub> => b* sia falsa nel modello. 
Allora la premessa deve essere vera e *b* falsa, ma questo contraddice l‚Äôassunto che l‚Äôalgoritmo abbia raggiunto un punto fisso.

Quindi *m* √® un modello per KB e se KB |= q, allora q √® vere in ogni modello della KB, incluso anche *m*.

## Backward chaining

L'idea √® quello di lavorare all'indietro a partire dalla query *q*.

Per provare *q* attraverso la KB, prima si controlla che *q* non sia gi√† conosciuta e nel caso questa non sia conisciuta, si provano trammite la KB tutte le premesse si una regola che deriva *q*.

√à importante evitare i cicli, bisogna quindi controllare se un nuovo sotto goal √® gi√† presente nella pila dei goal.

Si pu√≤ anche ottimizzare il lavoro, se ho un nuovo sottogoal posso controllare se l'ho gi√† provato vero o se √® gi√† fallito.

Non √® stato presentato un algoritmo a lezione perch√© una implementazione del Backward chaining √® molto complessa.

## Forward VS Backward

Forward √® pi√π orientata ai dati e viene utilizzata per l'elaborazione incoscia e automatica, come il riconoscimento dei dati.

A causa dell'approccio utilizzato viene eseguito del lavoro irrilevante per il goal, cio√© vengono dedotte molte conseguenze logiche che non sono rilevanti per il goal (come se fosse una ricerca a ventaglio).

Backward √® invece focalizzato sul goal, per questo motivo √® pi√π adatto al problem solving e la complessit√† di questa strategia pu√≤ essere molto minore che lineare nella complessit√† di KB, perch√© cerca di restringersi alle clausole rilevanti per raggiungere lo scopo (Forward √® lineare). 

FINE
___
## Regola di risoluzione

**Forma normale congiuntiva (CNF)**: forme di scrittura che utilizza congiunzione di disgiunzione di letterali (dove la disgiunzione di letterali √® una clausa di Horn).

> (A ‚ãÅ !B) ‚ãÄ (B ‚ãÅ !C ‚ãÅ !B)

La **risoluzione** √® una regola di inferenza per CNF completa e corretta per la logia proposizionale.

![](./immagini/l12-risoluzione.png)

In pratica si va a togliere un *l<sub>i</sub>* e *m<sub>j</sub>* che sono tra loro complementari (lo stesso letterale sia negato che non).

Questo procedimento esegue la verifica del modello perch√© vuol dire che se *L* e *M* sono vere e anche la proposizione che si deduce √® vera, quindi vuol dire che il letterale tolto non influenzava la verit√† di *L* e *M*.

La **correttezza** di questa regola √® semplice, se tolgo dalla clausola *L* il letterale *l* e dalla clausola *M* il letterale *m* che √® complementare a *l*, allora se *l* √® vero allora *m* √® falso e quindi *M* deve essere vero e non a causa di *m*. Se *l* √® falso, allora *L* deve essere vero senza *l*. Il valore di *l* quindi non incide ne in una clausola ne nell‚Äôaltra, quindi la sua eliminazione non altera il valore delle clausole.


###Conversione in CNF

> B<sub>1,1</sub> <==> (P<sub>1,2</sub> ‚ãÅ P<sub>2,1</sub>)

1. Eliminare il se e solo se
> (B<sub>1,1</sub> => (P<sub>1,2</sub> ‚ãÅ P<sub>2,1</sub>)) ‚ãÄ ((P<sub>1,2</sub> ‚ãÅ P<sub>2,1</sub>) => B<sub>1,1</sub>)

2. Eliminare il => rimpiazzando A => B con !A ‚ãÅ B
> (!B<sub>1,1</sub> ‚ãÅ P_1,2 ‚ãÅ P_2,1) ‚ãÄ (!(P_1,2 ‚ãÅ P_2,1) ‚ãÅ B_1,1) 

3. Spostare la negazione all'interno delle parentesi usando le regole di De Morgan
> (!B<sub>1,1</sub> ‚ãÅ P<sub>1,2</sub> ‚ãÅ P<sub>2,1</sub>) ‚ãÄ ((!P<sub>1,2</sub> ‚ãÄ !P<sub>2,1</sub>) ‚ãÅ B<sub>1,1</sub>) 

4. Si applica la legge distrubutiva dell'OR sull'AND
> (!B<sub>1,1</sub> ‚ãÅ P<sub>1,2</sub> ‚ãÅ P<sub>2,1</sub>) ‚ãÄ (!P<sub>1,2</sub> ‚ãÅ B<sub>1,1</sub>) ‚ãÄ (!P<sub>2,1</sub>) ‚ãÅ B<sub>1,1</sub>) 

A questo punto abbiamo la CNF.

###Algoritmo risolutivo

La **regola di risoluzione** √® le regola di inferenza precedentemente vista, l'aloritmo di risoluzione √® quello che applica pi√π volte la regola di risoluzione per andare a risolvere il problema.

L'algoritmo funziona per contraddizione, cio√® va a dimostrare che *KB ‚ãÄ !ùú∂* √® insoddisfacibile.

Se risolvendo KB ‚ãÄ !ùú∂ viene trovata la clausola vuota, allora vuol dire che KB ‚ãÄ !ùú∂ √® insoddisfacibile e di conseguenza KB |= ùú∂.

Da notare che l'algoritmo dice se ùú∂ √® conseguenza logica o meno dalla KB, senza fornire una prova del risultato.

```
function CP-Risoluzione(KB, ùú∂) return true oppure false
    clausole <- insieme di clausole nella rappresentazione CNF di KB ‚ãÄ !ùú∂
    new <- {}
    loop do
        foreach C_i C_j in clausole do
            resolvents <- CP-Risolvi(C_i, C_j)
            if resolvents contiene la clausola vuota then return true
            new <- new ‚à™ resolvents
        if new ‚äÜ clausole then return false
        clausole <- clausole ‚à™ new
```

`CP-Risolvi(C_i, C_j)` restituisce l'insieme dei risolventi ottenuti applicando la regola di risoluzione in tutti i modi possibili per le due clausole. Questo perch√© data una coppia di clausole √® possibile risolverle in pi√π modi diversi. 

Per prima cosa √® necessario convertire il tutto in CNF, quindi si applica la regola di risoluzione alle clausole risultati. 

Ogni coppia che contiene letterali complementari √® risolta per produrre una nuovo clausola che viene aggiunta all‚Äôinsieme.

Il processo continua finch√©:

- non √® pi√π possibile aggiungere alcuna clausola, in questo caso KB non implica ùú∂
- la risoluzione applicata a due clausole da come risultato la clausola vuota, in questo caso KB implica ùú∂
 
La clausola vuota, una disgiunzione senza alcun disgiunto √® equivalente a *False* perch√© una disgiunzione √® vera solo se √® vero almeno uno dei disgiunti.